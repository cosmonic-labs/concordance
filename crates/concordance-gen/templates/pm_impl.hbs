// TODO: unhardcode this opinion
use crate::eventsourcing::*;

use crate::*;

use wasmcloud_interface_logging::{error, debug};

#[derive(Debug, Default, Actor, HealthResponder)]
#[services(Actor, {{impltype}}Service)]
pub(crate) struct {{traitname}}{{impltype}}Impl {}

#[async_trait]
impl {{impltype}}Service for {{traitname}}{{impltype}}Impl {
    
    async fn handle_event(&self, _ctx: &Context, arg: &EventWithState) -> RpcResult<ProcessManagerAck> {
        let state: Option<{{traitname}}{{impltype}}State> = arg
         .state
         .clone()
         .map(|bytes| deserialize_json(&bytes).unwrap_or_default());

        Ok(match arg.event.event_type.as_str() {
            {{#each inbound_events as |input|}}
            {{input.name}}::TYPE => {
                {{../traitname}}{{../impltype}}::handle_{{method-name input.name}}(
                    self,
                    deserialize_json(&arg.event.payload)?,                    
                    state)?
                },
            {{/each}}
            e =>  {
                debug!("Unexpected event received '{e}'. Acking and moving on - Is interest configured properly??");
                ProcessManagerAck::ok(state, vec![])
            }
        })        
    }
}

fn deserialize_json<'de, T: Deserialize<'de>>(
    buf: &'de [u8],
) -> RpcResult<T> {
    serde_json::from_slice(buf).map_err(|e| format!("Deserialization failure: {e:?}").into())
}

fn serialize_json<T: Serialize>(data: &T) -> RpcResult<Vec<u8>> {
    serde_json::to_vec(data).map_err(|e| format!("Serialization failure: {e:?}").into())
}

impl ProcessManagerAck {
    pub fn ok(state: Option<impl Serialize>, cmds: CommandList) -> Self {
        Self {
            state: state.map(|s| serialize_json(&s).unwrap_or_default()),
            commands: cmds
        }
    }
}