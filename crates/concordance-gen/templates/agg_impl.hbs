// TODO: unhardcode this
use crate::eventsourcing::*;

use crate::*;

use wasmcloud_interface_logging::error;


#[derive(Debug, Default, Actor, HealthResponder)]
#[services(Actor, {{impltype}}Service)]
pub(crate) struct {{traitname}}{{impltype}}Impl {}

#[async_trait]
impl {{impltype}}Service for {{traitname}}{{impltype}}Impl {
    async fn handle_command(&self, _ctx: &Context, arg: &StatefulCommand) -> RpcResult<EventList> {
        {{#if inbound_commands}}
          let state: Option<{{traitname}}{{impltype}}State> = arg
            .state
            .clone()
            .map(|bytes| deserialize_json(&bytes).unwrap_or_default());

        match arg.command_type.as_str() {
             {{#each inbound_commands as |input|}}
                {{input.name}}::TYPE => {
                    {{../traitname}}{{../impltype}}::handle_{{method-name input.name}}(
                        self,
                        deserialize_json(&arg.payload)?,                        
                        state
                    )                   
                },
                
             {{/each}}                           
            e => {
                error!("Unsupported command type: {e}. Interest configuration for this {{impltype}} is probably incorect.");
                Ok(vec![])
            }
        }
        {{else}}
        Ok(vec![])
        {{/if}}
    }

    async fn apply_event(&self, _ctx: &Context, arg: &EventWithState) -> RpcResult<StateAck> {
        let state: Option<{{traitname}}{{impltype}}State> = arg
         .state
         .clone()
         .map(|bytes| deserialize_json(&bytes).unwrap_or_default());

        Ok(match arg.event.event_type.as_str() {
            {{#each inbound_events as |input|}}
            {{input.name}}::TYPE => {
                {{../traitname}}{{../impltype}}::apply_{{method-name input.name}}(
                    self,
                    deserialize_json(&arg.event.payload)?,                    
                    state)?
                },
            {{/each}}
            e =>   {
                debug!("Non-state-mutating event received '{e}'. Acking and moving on.");
                StateAck::ok(state)
            }
        })        
    }
}

fn deserialize_json<'de, T: Deserialize<'de>>(
    buf: &'de [u8],
) -> RpcResult<T> {
    serde_json::from_slice(buf).map_err(|e| format!("Deserialization failure: {e:?}").into())
}

fn serialize_json<T: Serialize>(data: &T) -> RpcResult<Vec<u8>> {
    serde_json::to_vec(data).map_err(|e| format!("Serialization failure: {e:?}").into())
}
