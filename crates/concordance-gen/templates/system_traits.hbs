// -- WARNING -- The code in this file has been generated by a tool. Do not edit it directly.

// TODO:
// 1. make it so we can generate individual traits rather than all of them

// NOTE: this requires all of the state structs to be imported by the root crate/module

use crate::*; // Import all of the public types exposed by this crate

{{#if aggregates}}
// Aggregates
{{#each aggregates as |agg|}}

/// {{title-case agg.name}} Aggregate Required Trait
pub trait {{trait-name agg.name}}Aggregate {
    {{#if agg.inbound}}
    // Commands
    {{#each agg.inbound_commands as |input|}}
    fn handle_{{method-name input.name}}(&self, input: {{input.name}}, state: Option<{{trait-name agg.name}}AggregateState>) -> RpcResult<EventList>;
    {{/each}}


    // Events
    {{#each agg.inbound_events as |input|}}
    fn apply_{{method-name input.name}}(&self, input: {{input.name}}, state: Option<{{trait-name agg.name}}AggregateState>) -> RpcResult<StateAck>;
    {{/each}}
    {{/if}}    
}

{{/each}}
{{/if}}

{{#if pms}}
// Process Managers
{{#each pms as |pm|}}

/// {{title-case pm.name}} Process Manager
pub trait {{trait-name pm.name}}ProcessManager {
    {{#if pm.inbound}}
    // Inputs
    {{#each pm.inbound as |input|}}
    fn handle_{{method-name input.name}}(&self, input: {{input.name}}, state: Option<{{trait-name pm.name}}ProcessManagerState>) -> RpcResult<ProcessManagerAck>;
    {{/each}}
    {{/if}}   
}

{{/each}}
{{/if}}

{{#if projectors}}
// Projectors
{{#each projectors}}

/// {{title-case name}} Projector
pub trait {{trait-name name}}Projector {
    {{#if inbound}}
    // Inputs
    {{#each inbound}}
    fn handle_{{method-name name}}(&self, input: {{name}}) -> RpcResult<()>;
    {{/each}}
    {{/if}}
}

{{/each}}
{{/if}}

{{#if notifiers}}
// Notifiers
{{#each notifiers}}

/// {{title-case name}} Notifier
pub trait {{trait-name name}}Notifier {
    {{#if inbound}}
    // Inputs
    {{#each inbound}}
    fn handle_{{method-name name}}(input: {{name}});
    {{/each}}
    {{/if}}
}

{{/each}}
{{/if}}